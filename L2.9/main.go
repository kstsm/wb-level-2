package main

import (
	"errors"
	"fmt"
	"strconv"
	"strings"
	"unicode"
)

//Написать функцию Go, осуществляющую примитивную распаковку строки, содержащей повторяющиеся символы/руны.
//Примеры работы функции:
//Вход: "a4bc2d5e"
//Выход: "aaaabccddddde"
//Вход: "abcd"
//Выход: "abcd" (нет цифр — ничего не меняется)
//Вход: "45"
//Выход: "" (некорректная строка, т.к. в строке только цифры — функция должна вернуть ошибку)
//Вход: ""
//Выход: "" (пустая строка -> пустая строка)
//Дополнительное задание
//Поддерживать escape-последовательности вида \:
//Вход: "qwe\4\5"
//Выход: "qwe45" (4 и 5 не трактуются как числа, т.к. экранированы)
//Вход: "qwe\45"
//Выход: "qwe44444" (\4 экранирует 4, поэтому распаковывается только 5)
//Требования к реализации
//Функция должна корректно обрабатывать ошибочные случаи (возвращать ошибку, например, через error), и проходить unit-тесты.
//Код должен быть статически анализируем (vet, golint).

// Код проходит unit-тесты (go test -v)

// Код прошел проверку на vet и golint
// Проверить golint:
// go golint ./...

// Проверить vet:
// go vet ./...

func unpackString(str string) (string, error) {

	// Если строка пустая, то возвращаем сразу пустую строку
	if str == "" {
		return "", nil
	}

	// Builder используем, чтобы эффективно делать конкатенацию
	var sb strings.Builder

	// prev хранит предыдущий символ для повторения цифрой
	var prev rune

	// escaped показывает, что следующий символ экранирован и его нужно добавить как есть
	escaped := false

	// Проходим по каждому символу
	for _, r := range str {
		if escaped {
			// Если предыдущий был \, то просто добавляем текущий символ
			sb.WriteRune(r)

			// Обновляем prev, чтобы цифра после экранированного символа могла его повторить
			prev = r

			// Возвращаем false
			escaped = false
			continue
		}

		if r == '\\' {
			// Обнаружили начало экранирования
			escaped = true
			continue
		}

		if unicode.IsDigit(r) {
			// Если встречаем цифру, повторяем предыдущий символ
			if prev == 0 {
				// Цифра без символа перед ней — некорректная строка
				return "", errors.New("invalid string")
			}
			// Преобразуем rune в число
			count, _ := strconv.Atoi(string(r))

			// Уже один символ добавлен, повторяем count-1 раз
			for i := 1; i < count; i++ {
				sb.WriteRune(prev)
			}
			continue
		}

		// Обычный символ добавляем в результат
		sb.WriteRune(r)

		// Обновляем prev для возможного повторения цифрой
		prev = r
	}

	// Возвращаем результат
	return sb.String(), nil
}

func main() {
	str := []string{
		"a4bc2d5e",
		"abcd",
		"45",
		"",
		"qwe\\4\\5",
		"qwe\\45",
	}

	for _, s := range str {
		res, err := unpackString(s)
		if err != nil {
			fmt.Println("input:", s, "error:", err)
		} else {
			fmt.Println("input:", s, "result:", res)
		}
	}
}
